// Generated by CoffeeScript 1.6.3
(function() {
  var Assets, Draw, DrawUtil, Entity, Game, GameTimer, MESHES, Mesh, SHADERS, Shader, ShaderUniform, ShaderUniformType, ShaderUniformTypeMethods, System, Texture, TextureManager, gl, initMeshes, initializeGame, main;

  Game = (function() {
    Game.prototype.running = false;

    Game.prototype.timer = null;

    Game.prototype.v = 0;

    function Game() {
      return;
    }

    Game.prototype.start = function() {
      this.timer = new GameTimer(this);
      this.running = true;
      return this.timer.start();
    };

    Game.prototype.update = function() {
      this.v += 0.01;
    };

    Game.prototype.render = function() {
      var i, _i;
      Draw.clear([0, 0, 0, 1]);
      Draw.setColor(vec4.clone([0, 1, 0, 1]));
      for (i = _i = 0; _i < 1; i = ++_i) {
        Draw.rect((i % 10) * 50, Math.floor(i / 10) * 50, 50, 50);
      }
      Draw.setColor(vec4.clone([0, 0, 1, 1]));
      Draw.rect(50 + Math.cos(this.v * Math.PI) * 50, 50 + Math.sin(this.v * Math.PI) * 50, 50, 50);
    };

    return Game;

  })();

  GameTimer = (function() {
    GameTimer.prototype.lt = 0;

    GameTimer.prototype.now = 0;

    GameTimer.prototype.delta = 0;

    GameTimer.prototype.ltr = 0;

    GameTimer.prototype.ticks = 0;

    GameTimer.prototype.frames = 0;

    GameTimer.prototype.mspt = 0;

    GameTimer.prototype.game = null;

    GameTimer.prototype.callback = null;

    GameTimer.prototype.start = function() {
      return window.requestAnimationFrame(this.callback);
    };

    GameTimer.prototype.getMillis = function() {
      return new Date().getTime();
    };

    function GameTimer(game) {
      var _this = this;
      this.game = game;
      this.lt = this.getMillis();
      this.now = this.lt;
      this.ltr = this.lt;
      this.mspt = 60.0 / 1000.0;
      this.callback = function(time) {
        return _this.update();
      };
    }

    GameTimer.prototype.update = function() {
      this.now = this.getMillis();
      this.delta += (this.now - this.lt) * this.mspt;
      this.lt = this.now;
      if (this.delta >= 10) {
        this.delta = 10;
      }
      while (this.delta >= 1) {
        this.game.update();
        this.ticks++;
        this.delta--;
      }
      this.game.render();
      this.frames++;
      if (this.now - this.ltr >= 1000) {
        this.ltr += 1000;
        this.ticks = 0;
        this.frames = 0;
      }
      if (this.game.running) {
        return window.requestAnimationFrame(this.callback);
      }
    };

    return GameTimer;

  })();

  initializeGame = function() {
    return Assets.init();
  };

  main = function() {
    DrawUtil.initGlContext();
    return new Game().start();
  };

  window.startGameMethod = main;

  Assets = (function() {
    function Assets() {}

    Assets.Textures = null;

    Assets.init = function() {
      return this.Textures = new TextureManager();
    };

    return Assets;

  })();

  TextureManager = (function() {
    function TextureManager() {}

    TextureManager.textures = {};

    TextureManager.add = function(name, path) {
      this.textures[name] = new Texture(path);
      if (typeof gl !== "undefined" && gl !== null) {
        this.textures[name].load();
      }
    };

    TextureManager.loadAll = function() {
      var text, _i, _len, _ref, _results;
      if (typeof gl === "undefined" || gl === null) {
        return;
      }
      _ref = this.textures;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        text = _ref[_i];
        _results.push(text.load());
      }
      return _results;
    };

    TextureManager.get = function(name) {
      return this.textures[name];
    };

    return TextureManager;

  })();

  Texture = (function() {
    Texture.prototype.width = 0;

    Texture.prototype.height = 0;

    Texture.prototype.image = null;

    Texture.prototype.texture = -1;

    Texture.prototype.path = "";

    Texture.prototype.loaded = false;

    function Texture(path) {
      this.path = path;
      return;
    }

    Texture.prototype.load = function() {
      var _this = this;
      if (this.loaded) {
        return;
      }
      this.image = new Image();
      this.image.onLoad = function() {
        _this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, _this.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
        _this.loaded = true;
      };
      this.image.src = this.path;
    };

    return Texture;

  })();

  Draw = (function() {
    function Draw() {}

    Draw.clear = function(col) {
      if (col == null) {
        col = [0, 0, 0, 1];
      }
      gl.clearColor(col[0], col[1], col[2], col[3]);
      return gl.clear(gl.COLOR_BUFFER_BIT);
    };

    Draw.setColor = function(color) {
      DrawUtil.shader.uniformColor.set(color);
    };

    Draw.rect = function(x, y, w, h, r) {
      var mat;
      if (r == null) {
        r = 0;
      }
      mat = mat4.create();
      mat4.identity(mat);
      mat4.translate(mat, mat, vec3.clone([x, y, 0]));
      if (r !== 0) {
        mat4.translate(mat, mat, vec3.clone([w / 2, h / 2, 0]));
        mat4.rotateZ(mat, mat, r);
        mat4.translate(mat, mat, vec3.clone([-w / 2, -h / 2, 0]));
      }
      mat4.scale(mat, mat, vec3.clone([w, h, 1]));
      MESHES.QUAD.render(mat);
    };

    return Draw;

  })();

  gl = null;

  DrawUtil = (function() {
    function DrawUtil() {}

    DrawUtil.canvas = null;

    DrawUtil.WIDTH = 854;

    DrawUtil.HEIGHT = 480;

    DrawUtil.shader = null;

    DrawUtil.initGlContext = function() {
      this.canvas = $("#gameCanvas")[0];
      this.canvas.width = this.WIDTH;
      this.canvas.height = this.HEIGHT;
      gl = this.__getGlContext();
      if (gl != null) {
        this.setupGlContext();
        this.setupShaders();
        return initMeshes();
      }
    };

    DrawUtil.__getGlContext = function() {
      return this.canvas.getContext("webgl") || this.canvas.getContext("experimental-webgl");
    };

    DrawUtil.setupGlContext = function() {
      gl.viewport(0, 0, this.WIDTH, this.HEIGHT);
      gl.disable(gl.DEPTH_TEST);
      return gl.disable(gl.CULL_FACE);
    };

    DrawUtil.setupShaders = function() {
      var camMat, viewMat;
      this.initShaders();
      this.shader = SHADERS[0].use();
      viewMat = mat4.create();
      mat4.identity(viewMat);
      mat4.ortho(viewMat, 0, this.WIDTH, this.HEIGHT, 0, -1, 1);
      this.shader.uniformViewMatrix.set(viewMat);
      camMat = mat4.create();
      mat4.identity(camMat);
      mat4.translate(camMat, camMat, vec3.clone([0, 0, 0]));
      this.shader.uniformCameraMatrix.set(camMat);
    };

    DrawUtil.initShaders = function() {
      var shader, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = SHADERS.length; _i < _len; _i++) {
        shader = SHADERS[_i];
        shader.getShaderCode(shader.vertexShaderCode, shader.fragmentShaderCode);
        if (!shader.compile()) {
          throw "Poop!";
        }
        _results.push(shader.setupAttribs());
      }
      return _results;
    };

    return DrawUtil;

  })();

  Mesh = (function() {
    function Mesh() {}

    Mesh.prototype.vertexBuffer = null;

    Mesh.prototype.indexBuffer = null;

    Mesh.prototype.size = null;

    Mesh.prototype.setVertices = function(vert) {
      if (this.vertexBuffer == null) {
        this.vertexBuffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      return gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vert), gl.STATIC_DRAW);
    };

    Mesh.prototype.render = function(mat) {
      var shader;
      shader = DrawUtil.shader;
      shader.uniformObjectMatrix.set(mat);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
      gl.vertexAttribPointer(shader.attributes[0], 2, gl.FLOAT, false, 16, 0);
      gl.vertexAttribPointer(shader.attributes[1], 2, gl.FLOAT, false, 16, 8);
      return gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    };

    return Mesh;

  })();

  MESHES = {
    "QUAD": new Mesh()
  };

  initMeshes = function() {
    return MESHES.QUAD.setVertices([0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1]);
  };

  Shader = (function() {
    Shader.prototype.vertexShader = null;

    Shader.prototype.fragmentShader = null;

    Shader.prototype.vertexShaderCode = "";

    Shader.prototype.fragmentShaderCode = "";

    Shader.prototype.program = null;

    Shader.prototype.attributes = [-1, -1];

    Shader.prototype.uniformViewMatrix = null;

    Shader.prototype.uniformCameraMatrix = null;

    Shader.prototype.uniformObjectMatrix = null;

    Shader.prototype.uniformColor = null;

    function Shader(vert, frag) {
      this.vertexShaderCode = vert;
      this.fragmentShaderCode = frag;
    }

    Shader.prototype.getShaderCode = function(vertex_id, fragment_id) {
      this.vertexShaderCode = $("#" + vertex_id)[0].innerText;
      console.log(this.vertexShaderCode);
      this.fragmentShaderCode = $("#" + fragment_id)[0].innerText;
      return console.log(this.fragmentShaderCode);
    };

    Shader.prototype.compile = function() {
      if (gl == null) {
        return;
      }
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this.vertexShader, this.vertexShaderCode);
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(this.vertexShader);
        return false;
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this.fragmentShader, this.fragmentShaderCode);
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(this.fragmentShader);
        return false;
      }
      this.program = gl.createProgram();
      gl.attachShader(this.program, this.vertexShader);
      gl.attachShader(this.program, this.fragmentShader);
      gl.linkProgram(this.program);
      if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        throw gl.getProgramInfoLog(this.program);
        return false;
      }
      return true;
    };

    Shader.prototype.setupAttribs = function() {
      this.attributes[0] = gl.getAttribLocation(this.program, "aPos");
      this.attributes[1] = gl.getAttribLocation(this.program, "aTexCoord");
      this.uniformViewMatrix = new ShaderUniform(this.program, "uViewMatrix", ShaderUniformType.MATRIX_4);
      this.uniformCameraMatrix = new ShaderUniform(this.program, "uCameraMatrix", ShaderUniformType.MATRIX_4);
      this.uniformObjectMatrix = new ShaderUniform(this.program, "uObjectMatrix", ShaderUniformType.MATRIX_4);
      this.uniformColor = new ShaderUniform(this.program, "uColor", ShaderUniformType.VECTOR_4);
      return this;
    };

    Shader.prototype.use = function() {
      gl.useProgram(this.program);
      gl.enableVertexAttribArray(this.attributes[0]);
      gl.enableVertexAttribArray(this.attributes[1]);
      return this;
    };

    return Shader;

  })();

  SHADERS = [new Shader("basic-vs", "basic-fs")];

  ShaderUniformType = {
    VECTOR_3: 0,
    VECTOR_4: 1,
    VECTOR_2: 2,
    MATRIX_4: 3
  };

  ShaderUniformTypeMethods = [
    function(uni, val) {
      return gl.uniform3fv(uni, val);
    }, function(uni, val) {
      return gl.uniform4fv(uni, val);
    }, function(uni, val) {
      return gl.uniform2fv(uni, val);
    }, function(uni, val) {
      return gl.uniformMatrix4fv(uni, false, val);
    }
  ];

  ShaderUniform = (function() {
    ShaderUniform.prototype.name = "";

    ShaderUniform.prototype.type = -1;

    ShaderUniform.prototype.uniform = null;

    ShaderUniform.prototype.value = null;

    function ShaderUniform(prog, name, type) {
      this.name = name;
      this.type = type;
      this.uniform = gl.getUniformLocation(prog, this.name);
    }

    ShaderUniform.prototype.set = function(val) {
      this.val = val;
      return ShaderUniformTypeMethods[this.type](this.uniform, val);
    };

    return ShaderUniform;

  })();

  Entity = (function() {
    Entity.prototype.components = [];

    function Entity() {
      return;
    }

    Entity.prototype.update = function() {};

    Entity.prototype.render = function() {};

    return Entity;

  })();

  System = (function() {
    System.prototype.entities = [];

    function System() {
      return;
    }

    System.prototype.update = function() {};

    System.prototype.render = function() {};

    return System;

  })();

}).call(this);
